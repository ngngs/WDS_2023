# 클린코드 33일차

## 18장 동시성2 (1)

### 개요
225쪽에서 소개한 동시성(Concurrency)에 대해 더 자세히 설명하는 장

### 가능한 실행 경로
아래 IdGenerator 인스턴스 1개를 스레드 2개가 공유할 때 가능한 실행 경로는? (초기값 0)
```java
public class IdGenerator{
    int lastIdUsed;
    
    public intincrementValue(){
        return ++lastIdUsed;
    }
}
```
- 스레드 1이 1을 얻고, 스레드 2가 2를 얻어, lastIdUsed가 2가 된다. 
- 스레드 1이 2를 얻고, 스레드 2가 1을 얻어, lastIdUsed가 2가 된다. 
- **스레드 1이 1을 얻고, 스레드 2가 1을 얻어, lastIdUsed가 1이 된다.** 

놀랍게도 마지막 경우도 가능한데, 이는 **'가능한 실행 경로 수'**와 **'JVM의 동작 방식'**을 알아야 한다.

#### (1) 경로 수
> 루프나 분기가 없는 명령 N개를 스레드 T개가 차례로 실행할 때 가능한 경로 수<br/>
> - 가능한 경로 수 : (NT)! / (N!)^T 

**가능한 경로 수를 계산하기 위해 자바 컴파일러가 생성한 바이트 코드를 살펴봐야** 한다.  <br/>
`return ++lastIdUsed;`라는 자바 코드 한 줄은 바이트 코드 명령 8개에 해당한다.  <br/>
따라서 2개의 스레드가 명령 8개를 뒤섞어 실행하는 것과 같다.


#### (2) 가능한 순열 수 계산하기
우리가 예제로 사용한 자바 코드 한 줄은 N=8이고 T=2이다. 따라서 가능한 경로 수는 12,870개다.

만약 lastIdUsed가 long 정수라면 읽기/쓰기 명령이 한 단계가 아니라 두 단계로 실행되기에 가능한 경로 수는 2,704,156개로 늘어나게 된다.

만약 메서드를 아래처럼 synchronized를 걸어준다면 가능한 경로 수는 2개로 줄어든다. 스레드가 N개라면 가능한 경로 수는 N!이다.
```java
public synchronized void incrementValue(){
    ++lastIdUsed;    
}
```